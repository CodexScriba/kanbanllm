// lib/validators.ts
import { z } from 'zod';
import { FrontmatterSchema, normalizeStageValue } from './parser';
import { findItemById } from './fs-adapter';
import type { Stage, ItemType, Frontmatter } from './types';

const VALID_STAGES: Stage[] = ['chat', 'queue', 'plan', 'code', 'audit', 'completed'];
const VALID_ITEM_TYPES: ItemType[] = ['phase', 'task'];

/**
 * Type guard for Stage
 */
export function validateStage(stage: string): stage is Stage {
  return VALID_STAGES.includes(stage as Stage);
}

/**
 * Type guard for ItemType
 */
export function validateItemType(type: string): type is ItemType {
  return VALID_ITEM_TYPES.includes(type as ItemType);
}

/**
 * Validates filename format
 * Expected format: {slug}-{hash}.md or {prefix}-{slug}-{hash}.md
 */
export function validateFilename(filename: string): boolean {
  // Remove .md extension if present
  const nameWithoutExt = filename.endsWith('.md') ? filename.slice(0, -3) : filename;

  // Check if it ends with a 4-character hash
  const parts = nameWithoutExt.split('-');

  if (parts.length < 2) {
    return false;
  }

  const hash = parts[parts.length - 1];

  // Hash should be 4 characters, alphanumeric (base36)
  return /^[a-z0-9]{4}$/.test(hash);
}

/**
 * Validates frontmatter using Zod schema
 */
export function validateFrontmatter(data: unknown): Frontmatter {
  try {
    const parsed = FrontmatterSchema.parse(data);
    return {
      ...parsed,
      stage: normalizeStageValue(parsed.stage),
    } as Frontmatter;
  } catch (error) {
    if (error instanceof z.ZodError) {
      const errors = error.errors.map(err => `${err.path.join('.')}: ${err.message}`).join(', ');
      throw new Error(`Invalid frontmatter: ${errors}`);
    }
    throw error;
  }
}

/**
 * Validates that a phase exists
 */
export async function validatePhaseExists(phaseId: string): Promise<boolean> {
  const phasePath = await findItemById(phaseId);
  return phasePath !== null;
}

/**
 * Validates that required fields are present for creating an item
 */
export function validateCreateItemData(data: {
  type?: string;
  title?: string;
  stage?: string;
  phase?: string;
}): {
  valid: boolean;
  errors: string[];
} {
  const errors: string[] = [];

  // Type is required
  if (!data.type) {
    errors.push('Type is required');
  } else if (!validateItemType(data.type)) {
    errors.push(`Invalid type: ${data.type}. Must be 'phase' or 'task'`);
  }

  // Title is required
  if (!data.title || data.title.trim().length === 0) {
    errors.push('Title is required');
  }

  // Stage is required
  if (!data.stage) {
    errors.push('Stage is required');
  } else if (!validateStage(data.stage)) {
    errors.push(`Invalid stage: ${data.stage}. Must be one of: ${VALID_STAGES.join(', ')}`);
  }

  // Phase is required for tasks
  if (data.type === 'task' && (!data.phase || data.phase.trim().length === 0)) {
    errors.push('Phase is required for tasks');
  }

  return {
    valid: errors.length === 0,
    errors,
  };
}

/**
 * Validates that dependencies exist
 */
export async function validateDependencies(dependencies: string[]): Promise<{
  valid: boolean;
  missing: string[];
}> {
  const missing: string[] = [];

  for (const depId of dependencies) {
    const exists = await validatePhaseExists(depId);
    if (!exists) {
      missing.push(depId);
    }
  }

  return {
    valid: missing.length === 0,
    missing,
  };
}

/**
 * Validates item ID format
 */
export function validateItemId(id: string): boolean {
  // Should match the format generated by generateId
  // e.g., "implement-kanban-b7c1" or "phase1-task1-kanban-b7c1"
  const parts = id.split('-');

  if (parts.length < 2) {
    return false;
  }

  // Last part should be 4-char hash
  const hash = parts[parts.length - 1];
  return /^[a-z0-9]{4}$/.test(hash);
}

/**
 * Sanitizes a title for use in filenames
 */
export function sanitizeTitle(title: string): string {
  return title
    .toLowerCase()
    .replace(/[^a-z0-9\s-]/g, '')
    .trim()
    .replace(/\s+/g, '-');
}

/**
 * Validates stage transition
 * Returns true if transition is allowed, false otherwise
 */
// eslint-disable-next-line @typescript-eslint/no-unused-vars
export function validateStageTransition(_from: Stage, _to: Stage): boolean {
  // For MVP, all transitions are allowed
  // In future, we could add rules like:
  // - Can't skip stages
  // - Can't move backward
  // - etc.
  return true;
}

/**
 * Gets all valid stages
 */
export function getValidStages(): Stage[] {
  return [...VALID_STAGES];
}

/**
 * Gets all valid item types
 */
export function getValidItemTypes(): ItemType[] {
  return [...VALID_ITEM_TYPES];
}

/**
 * Schema for updating item metadata
 */
export const UpdateItemSchema = z.object({
  title: z.string().min(1, 'Title cannot be empty').max(200, 'Title is too long').optional(),
  tags: z.array(z.string().max(50, 'Tag is too long')).max(20, 'Too many tags').optional(),
  dependencies: z.array(z.string().regex(/^[a-z0-9-]+$/, 'Invalid dependency ID format')).max(50, 'Too many dependencies').optional(),
  assignees: z.array(z.string().max(100, 'Assignee name is too long')).max(20, 'Too many assignees').optional(),
}).strict(); // Prevent unexpected fields

export type UpdateItemData = z.infer<typeof UpdateItemSchema>;
